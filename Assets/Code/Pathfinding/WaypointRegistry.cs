//------------------------------------------------------------------------------
// <auto-generated>
//     Dieser Code wurde von einem Tool generiert.
//     Laufzeitversion:4.0.30319.42000
//
//     Änderungen an dieser Datei können falsches Verhalten verursachen und gehen verloren, wenn
//     der Code erneut generiert wird.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Linq;
using UnityEngine;
using System.Collections.Generic;

public class WaypointRegistry {
	private static WaypointRegistry _instance;

	public static WaypointRegistry Instance {
		get {
			if (_instance == null) {
				_instance = new WaypointRegistry();
			}
			return _instance;
		}
	}

	private List<Waypoint> knownWaypoints;

	private WaypointRegistry() {
		// Alloc space for 50 waypoints. That will do
		this.knownWaypoints = new List<Waypoint>(50);
	}

	public void Clear() {
		this.knownWaypoints.Clear();
	}

	public void Add(Waypoint wp) {
		this.knownWaypoints.Add(wp);
	}

	public void Remove(Waypoint wp) {
		this.knownWaypoints.Remove(wp);
	}

//	public Waypoint GetClosest(Vector2 position, Waypoint notThis) {
//		return GetClosest(position, notThis, Waypoint.WaypointType.EDGE, Waypoint.WaypointType.WALKABLE);
//	}

	public Waypoint GetClosest(Vector2 position, Waypoint notThis, params Waypoint.WaypointType[] wpType) {
		float shortestDistance = -1;
		Waypoint wp = null;
		for (int i = 0; i < knownWaypoints.Count; ++i) {

			if (knownWaypoints[i] == notThis || (wpType.Length > 0 && !wpType.Contains(knownWaypoints[i].Type))) {
				continue;
			}
			float distance = Vector2.Distance(knownWaypoints[i].Position, position);
			if (shortestDistance < 0 || distance < shortestDistance) {
				shortestDistance = distance;
				wp = knownWaypoints[i];
			}
		}
		return wp;
	}

//	public Waypoint GetClosestOfType(Waypoint.WaypointType type, Vector2 position) {
//		float shortestDistance = -1;
//		Waypoint wp = null;
//		for (int i = 0; i < knownWaypoints.Count; ++i) {
//			if (knownWaypoints[i].Type == type) {
//				float distance = Vector2.Distance(knownWaypoints[i].Position, position);
//				// Check general distance and the difference in y height so we don't try to find waypoints aboce us
//				if (shortestDistance < 0 || distance < shortestDistance && Mathf.Abs (position.y - knownWaypoints[i].Position.y) < 0.5f) {
//					shortestDistance = distance;
//					wp = knownWaypoints[i];
//				}
//			}
//		}
//		return wp;
//	}
//
//	public Waypoint GetClosestInDirection(Vector2 direction, Vector2 position, Waypoint notThis) {
//		float shortestDistance = -1;
//		Waypoint wp = null;
//		for (int i = 0; i < knownWaypoints.Count; ++i) {
//			if (knownWaypoints[i] == notThis) {
//				continue;
//			}
//			// Finds some waypoint in a given direction (left or right)
//			if ((knownWaypoints[i].Position.x <= position.x && direction == Vector2.left) || (knownWaypoints[i].Position.x >= position.x && direction == Vector2.right)) {
//
//				float distance = Vector2.Distance(knownWaypoints[i].Position, position);
//				// Check general distance and the difference in y height so we don't try to find waypoints aboce us
//				if (shortestDistance < 0 || distance < shortestDistance && Mathf.Abs (position.y - knownWaypoints[i].Position.y) < 1.5f) {
//					shortestDistance = distance;
//					wp = knownWaypoints[i];
//				}
//			}
//		}
//		return wp;
//	}
}

